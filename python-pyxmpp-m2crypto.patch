--- pyxmpp-1.0.0/pyxmpp/streamtls.py.orig	2005-12-26 16:25:47.000000000 +0100
+++ pyxmpp-1.0.0/pyxmpp/streamtls.py	2006-12-07 00:06:52.272342454 +0100
@@ -337,7 +337,7 @@
             self.__logger.debug("tls_verify_callback(depth=%i,ok=%i)" % (depth,ok))
             from M2Crypto.SSL.Context import map as context_map
             from M2Crypto import X509,m2
-            ctx=context_map()[ssl_ctx_ptr]
+            ctx=context_map()[long(ssl_ctx_ptr)]
             cert=X509.X509(x509_ptr)
             cb=self.tls_settings.verify_callback
 
@@ -367,7 +367,7 @@
             else:
                 return ok
         except:
-            self.__logger.exception("Exception cought")
+            self.__logger.exception("Exception caught")
             raise
 
     def get_tls_connection(self):
@@ -378,21 +378,24 @@
 
 TLS_ERR_BAD_CN=1001
 
-def cert_verify_callback(ssl_ctx_ptr, x509_ptr, errnum, depth, ok):
+def cert_verify_callback(ok, store):
     """Pass control to the right verification function for a TLS connection.
 
     M2Crypto doesn't associate verification callbacks with connection, so
     we have one global callback, which finds and calls right callback.
 
     :Parameters:
-        - `ssl_ctx_ptr`: TLS context pointer.
-        - `x509_ptr`: X.509 certificate pointer.
-        - `errnum`: error number.
-        - `depth`: verification depth.
         - `ok`: current verification result.
+        - `store`: X.509 certificate store.
     """
     from M2Crypto.SSL.Context import map as context_map
-    ctx=context_map()[ssl_ctx_ptr]
+    from M2Crypto import m2
+    # get old cert_verify_callback args from store (ssl_ctx_ptr,x509_ptr,errnum,depth)
+    ssl_ctx_ptr=m2.ssl_get_ssl_ctx(m2.x509_store_ctx_get_ssl(store.ctx))
+    x509_ptr=store.get_current_cert().x509
+    errnum=store.get_error()
+    depth=store.get_error_depth()
+    ctx=context_map()[long(ssl_ctx_ptr)]
     if hasattr(ctx,"_pyxmpp_stream"):
         stream=ctx._pyxmpp_stream
         if stream:
